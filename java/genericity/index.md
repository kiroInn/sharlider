# genericity

jdk1.5 新特性 
泛型 枚举 innovation

# 泛型问题引出

现在假设需要你顶一个描述坐标的程序类Ponit类，坐标x,y 
可能情况 x=10 y=20  x=10.1 y=20.1
那么现在首要解决的问题就是Point类中 x , y的属性类型问题，那么此时需要保存的有int，double，String 那么只有一种类型可以保存所有的类型:Object

int自动装箱为Integer  double自动装箱为Double 

这一切看起来已经彻底解决了问题,但是现在解决问题的关键是Object，于是问题也即将在Object产生.
观察程序的问题
向下转型是不安全的操作,会带来隐患。

# 泛型使用

所谓的泛型指的就是在类定义的时候
并不会设置类中的属性或方法的具体的类型
而是在类使用的时候在进行定义
所以如果想要进行这种泛型的操作
就需要做一个类型标记的声明


当我们开发的程序可以避免向下转型
意味着安全隐患被消除了
尽量不要去使用向下转型(ClassCastException)
泛型可以帮我们解决程序中参数类型转换

# 通配符

虽然在程序类中追加有泛型的定义后避免了ClassCastExcepiton
但是会产生新的情况
参数统一问题

而在"?"的基础上又产生了两个子通配符：
 ? extends 类: 设置泛型的上限
    ? extends Number 只能设置其子类 
 ？ super 类: 设置其泛型下限

"?" 代表能接受一切但不你能修改

# 泛型接口

泛型可以定义类,也可以定义在接口上

泛型接口的定义形式
1 在子类定义的时候继续使用泛型
2 在实现接口的时候明确给出具体类型

# 泛型方法

在之前定义的类或接口上都可以在里面的方法中使用泛型
但是泛型方法不一定定义在泛型类或者泛型接口中
可以单独定义

# 枚举

枚举几乎所有的编程语言都支持的数据类型

多例设计模式
限制本类产生实例化对象产生个数
这个是在jdk1.5之前的做法

实际上所谓的枚举就是一种高级的多例设计模式。

# enum类

jdk1.5 提供了enum关键字
但不是新的结构 只是对一种类型的包装

# enum与Enum的区别?

enum是一个关键字
使用enum定义的枚举类本质上就相当于一个类继承了Enum抽象类而已

枚举定义属性与方法
枚举实现接口

# Annotation

注解是JDK发现的一项重要技术
基本所有的现代应用框架都有使用

软件开发发展过程

JDK三个内置注解
@Override  @Deprecated @SuppressWarning

# @Override

方法覆写
发生继承关系之中
子类定义了与父类方法名称相同
参数类型及个数,返回值类型相同

# @Deprecated

过期声明
版本迭代过程老功能不推荐使用
能不用就不用

# @SuppressWarnings

压制警告
当调用了某些操作可能产生问题的时候就会出现警告信息

# jdk1.8 

接口定义增强
Lambda

面向对象编程要求：结构必须完整
函数式编程：接口必须只有一个方法 
@FunctionalInterface

语法 () -> { .... }
如果只有一条语句可以省略大括号

# 方法引用

类 接口 数组具备引用操作
jdk1.8追加了方法引用
引用本质就是别名

java提供四种形式方法引用

:静态方法 类名称 :: static method
:对象方法 实例化对象 :: 普通方法
:类中普通方法 类名称 
:构造方法 类名称 :: new

# 函数式接口

若要进行复杂的lambda运算
就需要学习函数式接口进行操作

java提供了4中函数式接口

功能型接口
消费性接口
供给型
断言型
