[New Feature](/#2)

jdk1.2 推出了轻量级的javaGUI的设计组件包
jdk1.5 推出了新的程序结构的设计思想
jdk1.8 lambda表达式、接口加强

到现在为止已经接触过新特性
自动拆箱装箱

# 可变参数

现在假设说又这样一个要求
参数个数不确定,随意由用户传递
要求设计一个方法
用于计算输入整数的相加结果

# 注意

若要传递多类参数
可变参数要写在最后

# 增强型for循环(foreach)

原始数组通过for循环
没有必要在使用索引遍历数据了
此方式避免掉数组越界问题
但这种操作是适合于简单的处理模式

# 格式

for(数据类型 临时变量: 数组)
{而每一次的循环都会顺序取出数组的一个元素复制给临时变量}

# 静态导入

从jdk1.5开始
如果发现类中的方法全都是static方法
则可以将这个类的方法导进来
这样他就好比在主类中直接调用

# 点餐小程序

设计一个类Food filds: title price category
实例化多个Food egg 麻婆豆腐 9.9 川菜 ....
使用可变参数  增强for循环 实现计总价(total) 与 均价(avg)方法

# Home Work
(餐名很粗心)

基于点餐小程序 增加新功能
由于服务员员粗心(手抖)录入很多重复字符
例如"手手撕包包包包菜菜菜菜"
剔除食物品名连续字符,只保留一个
处理完之后返回"手撕包菜"
需要设计一个餐盘类(FoodPlate) filds: Food[] foods
餐盘保存的食物需要序列化保存到 foodPlate.ser文件
并试着读取文件 看是否序列化成功

jdk1.5 新特性 
泛型 枚举 Annotation

# genericity

# 泛型问题引出

# 泛型

泛型指在类定义的时候
不设置类中属性或方法的具体类型
而是在类使用的时候在进行定义
所以如果想要进行这种泛型的操作
就需要做一个类型标记的声明

当我们开发的程序可以避免向下转型
意味着安全隐患被消除了
消除(ClassCastException)

但是会产生新的情况
参数统一问题

# 通配符

而在"?"的基础上又产生了两个子通配符：
 ? extends 类: 设置泛型的上限
    ? extends Number 只能设置其子类 
 ？ super 类: 设置其泛型下限

"?" 代表能接受一切但不你能修改

# 泛型接口

泛型可以定义类
也可以定义在接口上

泛型接口定义形式
1 在子类定义的时候继续使用泛型
2 在实现接口的时候明确给出具体类型

# 泛型方法

在之前定义的类或接口上都可以在里面的方法中使用泛型
但是泛型方法不一定定义在泛型类或者泛型接口中
可以单独定义

# 枚举

枚举几乎所有的编程语言都支持的数据类型

多例设计模式
限制本类产生实例化对象产生个数
这个是在jdk1.5之前的做法

实际上所谓的枚举就是一种高级的多例设计模式。

# enum类

jdk1.5 提供了enum关键字
但不是新的结构 只是对一种类型的包装

# enum与Enum的区别?

enum是一个关键字
使用enum定义的枚举类本质上就相当于一个类继承了Enum抽象类而已

枚举定义属性与方法
枚举实现接口

# Annotation

注解是JDK发现的一项重要技术
基本所有的现代应用框架都有使用

软件开发发展过程

JDK三个内置注解
@Override  @Deprecated @SuppressWarning

# @Override

方法覆写
发生继承关系之中
子类定义了与父类方法名称相同
参数类型及个数,返回值类型相同

# @Deprecated

过期声明
版本迭代过程老功能不推荐使用
能不用就不用

# @SuppressWarnings

压制警告
当调用了某些操作可能产生问题的时候就会出现警告信息

# jdk1.8 

接口定义增强
Lambda

面向对象编程要求：结构必须完整
函数式编程：接口必须只有一个方法 
@FunctionalInterface

语法 () -> { .... }
如果只有一条语句可以省略大括号

# 方法引用

类 接口 数组具备引用操作
jdk1.8追加了方法引用
引用本质就是别名

java提供四种形式方法引用

:静态方法 类名称 :: static method
:对象方法 实例化对象 :: 普通方法
:类中普通方法 类名称 
:构造方法 类名称 :: new

# 函数式接口

若要进行复杂的lambda运算
需要学习函数式接口进行操作

java提供了4中函数式接口

功能型接口(Function)
消费性接口(Consumer)
供给型(Supplier)
断言型(Predicate)
